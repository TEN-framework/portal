---
title: Graph
---

In the TEN framework, there are two types of graphs:

1. Dynamic Graph
2. Predefined Graph (`predefined_graph`)

|               | Dynamic Graph                                       | Predefined Graph                                                       |
| ------------- | --------------------------------------------------- | ---------------------------------------------------------------------- |
| Startup Time  | When the TEN app receives the `start_graph` command | When the TEN app starts, or when it receives the `start_graph` command |
| Graph Content | Specified in the `start_graph` command              | Predefined in the TEN app's properties                                 |
| Graph ID      | Randomly generated UUID                             | Randomly generated UUID                                                |

![Two types of graphs](/assets/png/two_types_of_graph.png)

Predefined graphs have an `auto_start` property to determine whether the graph automatically starts when the TEN app launches.

Additionally, predefined graphs have a `singleton` property that indicates whether only _one_ instance of the graph can be generated within the TEN app.

## Graph ID and Graph Name

For each graph instance, the TEN app internally uses a unique UUID4 string as an identifier, called the **Graph ID**.

For predefined graphs, you can assign a meaningful and easy-to-remember name, called the **Graph Name**. When you need to specify a particular predefined graph, you can directly use its graph name. If a predefined graph has the `singleton` property, it means that only one instance of this predefined graph can exist within the TEN app. In this case, the TEN runtime platform uses the graph name to uniquely identify the single instance generated from that predefined graph.

## Dynamic Graph

When a TEN app receives a `start_graph` command and creates a dynamic graph, the system assigns a random UUID as the graph's ID. If other clients obtain this graph ID, they can also connect to this graph.

Dynamic Graph ID example:

`123e4567-e89b-12d3-a456-426614174000`

## Predefined Graph

Predefined graphs work similarly to dynamic graphs, with the main difference being how the content is defined. The content of a dynamic graph is included in the `start_graph` command, while the content of a predefined graph is defined in advance by the TEN app. Clients only need to specify the name of the predefined graph in the `start_graph` command to start it.

The main advantage of predefined graphs is simplifying usage and protecting sensitive information. With predefined graphs, clients don't need to know the detailed structure of the graph, which both improves usability and avoids exposing potentially sensitive information contained in the graph.

Predefined Graph name example:

`http_server`

When a TEN app starts, all predefined graphs with the `auto_start` property set will automatically start.

## Graph Definition

Whether it's a dynamic graph or a predefined graph, the definition structure is the same:

```json
{
  "nodes": [
    // Definition of nodes
  ],
  "connections": [
    // Definition of communication links
  ]
}
```

Key points:

1. If there is only one TEN app, you can omit the `app` field. If there are multiple apps, you must explicitly specify the `app` field.

2. The `nodes` field defines the nodes in the graph, such as various extensions.

3. Each node can appear only once in the `nodes` field. If the same node appears multiple times, the TEN framework will report an error during validation.

4. The way to define an extension in the `nodes` field is as follows, where the `property` field is optional:

   ```json
   {
     "type": "extension",
     "name": "simple_http_server_cpp",
     "addon": "simple_http_server_cpp",
     "extension_group": "default_extension_group",
     "app": "msgpack://127.0.0.1:8001/",
     "property": {
       "root_key": "player",
       "extra_keys": ["playerName"]
     }
   }
   ```

   The `addon` field indicates that the extension is an instance generated by the corresponding plugin.

5. The `connections` field defines the communication links between nodes in the graph, where the `extension` value represents the name of the corresponding node.

Complete example:

```json
{
  "nodes": [
    {
      "type": "extension",
      "app": "msgpack://127.0.0.1:8001/",
      "name": "simple_http_server_cpp",
      "addon": "simple_http_server_cpp",
      "extension_group": "default_extension_group",
      "property": {
        "root_key": "player",
        "extra_keys": ["playerName"]
      }
    }
  ],
  "connections": [
    {
      "app": "msgpack://127.0.0.1:8001/",
      "extension": "simple_http_server_cpp",
      "cmd": [
        {
          "name": "start",
          "dest": [
            {
              "app": "msgpack://127.0.0.1:8001/",
              "extension": "gateway"
            }
          ]
        },
        {
          "name": "stop",
          "dest": [
            {
              "app": "msgpack://127.0.0.1:8001/",
              "extension": "gateway"
            }
          ]
        }
      ]
    },
    {
      "app": "msgpack://127.0.0.1:8001/",
      "extension": "gateway",
      "cmd": [
        {
          "name": "push_status_online",
          "dest": [
            {
              "app": "msgpack://127.0.0.1:8001/",
              "extension": "uap"
            }
          ]
        }
      ]
    }
  ]
}
```

## Predefined Graph Definition

Predefined graphs are defined under the `predefined_graphs` field in the TEN app's configuration file (`property.json`), including properties such as `name`, `auto_start`, and `singleton`:

```json
{
  "ten": {
    "predefined_graphs": [
      {
        "name": "default",
        "auto_start": true,
        "singleton": true,
        // Complete graph definition
      }
    ]
  }
}
```

Complete example:

```json
{
  "ten": {
    "predefined_graphs": [
      {
        "name": "default",
        "auto_start": true,
        "singleton": true,
        "nodes": [
          {
            "type": "extension",
            "name": "simple_http_server_cpp",
            "addon": "simple_http_server_cpp",
            "extension_group": "default_extension_group",
            "property": {
              "root_key": "player",
              "extra_keys": [
                "playerName"
              ]
            }
          }
        ],
        "connections": [
          {
            "app": "msgpack://127.0.0.1:8001/",
            "extension": "simple_http_server_cpp",
            "cmd": [
              {
                "name": "start",
                "dest": [
                  {
                    "app": "msgpack://127.0.0.1:8001/",
                    "extension": "gateway"
                  }
                ]
              },
              {
                "name": "stop",
                "dest": [
                  {
                    "app": "msgpack://127.0.0.1:8001/",
                    "extension": "gateway"
                  }
                ]
              }
            ]
          },
          {
            "app": "msgpack://127.0.0.1:8001/",
            "extension": "gateway",
            "cmd": [
              {
                "name": "push_status_online",
                "dest": [
                  {
                    "app": "msgpack://127.0.0.1:8001/",
                    "extension": "uap"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
```

## Definition of the `start_graph` Command

Dynamic graphs are created by sending a `start_graph` command to the TEN app, placing the graph definition under the `ten` field of the command:

```json
{
  "ten": {
    "type": "start_graph",
    // Complete graph definition
  }
}
```

Complete example:

```json
{
  "ten": {
    "type": "start_graph",
    "nodes": [
      {
        "type": "extension",
        "name": "simple_http_server_cpp",
        "addon": "simple_http_server_cpp",
        "extension_group": "default_extension_group",
        "property": {
          "root_key": "player",
          "extra_keys": ["playerName"]
        }
      }
    ],
    "connections": [
      {
        "app": "msgpack://127.0.0.1:8001/",
        "extension": "simple_http_server_cpp",
        "cmd": [
          {
            "name": "start",
            "dest": [
              {
                "app": "msgpack://127.0.0.1:8001/",
                "extension": "gateway"
              }
            ]
          },
          {
            "name": "stop",
            "dest": [
              {
                "app": "msgpack://127.0.0.1:8001/",
                "extension": "gateway"
              }
            ]
          }
        ]
      },
      {
        "extension": "gateway",
        "cmd": [
          {
            "name": "push_status_online",
            "dest": [
              {
                "extension": "uap"
              }
            ]
          }
        ]
      }
    ]
  }
}
```

### Using `source_uri` to Reference Graph Definitions

When defining a predefined graph, you can use the `source_uri` field to reference an external graph definition file:

```json
{
  "ten": {
    "uri": "http://localhost:8001",
    "predefined_graphs": [
      {
        "name": "default",
        "auto_start": false,
        "source_uri": "../graph.json"
      }
    ]
  }
}
```

`source_uri` can be a relative path, an absolute path, or a URL:

- Relative path: Relative to the directory where the `property.json` file is located
- Absolute path: Relative to the root directory of the TEN app environment
- URL: Processed directly as a URL path

## Graph Definition Specifications

- **`nodes` Field**: The `nodes` array must be provided in the graph definition. In comparison, the `connections` array is optional, but it's recommended to provide it to define communication between nodes.

- **Node `app` Field**: The `app` field cannot be set to `localhost`. In single-app graphs, the `app` URI should be omitted; in multi-app graphs, the value of the `app` field must match the `ten.uri` value in each app's `property.json`.

- **Node Uniqueness**: Each node in the `nodes` array represents a specific extension instance and must be uniquely identified by the combination of `app` and `name`. Duplicate definitions are not allowed, as shown in this invalid example:

  ```json
  {
    "nodes": [
      {
        "type": "extension",
        "name": "some_ext",
        "addon": "addon_1",
        "extension_group": "test"
      },
      {
        "type": "extension",
        "name": "some_ext",
        "addon": "addon_2",
        "extension_group": "test"
      }
    ]
  }
  ```

- **Consistency of Connection Definitions**: All extension instances referenced in `connections` must be explicitly defined in `nodes`. The following example is invalid because `ext_2` is not defined in `nodes`:

  ```json
  {
    "nodes": [
      {
        "type": "extension",
        "name": "ext_1",
        "addon": "addon_1",
        "extension_group": "some_group"
      }
    ],
    "connections": [
      {
        "extension": "ext_1",
        "cmd": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          }
        ]
      }
    ]
  }
  ```

- **Integration of Communication Links**: All messages from the same source extension should be grouped in a single section, not scattered across multiple definitions. The following example is incorrect:

  ```json
  {
    "connections": [
      {
        "extension": "ext_1",
        "cmd": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          }
        ]
      },
      {
        "extension": "ext_1",
        "data": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          }
        ]
      }
    ]
  }
  ```

  The correct approach is to integrate all messages from the same source extension:

  ```json
  {
    "connections": [
      {
        "extension": "ext_1",
        "cmd": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          }
        ],
        "data": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          }
        ]
      }
    ]
  }
  ```

- **Integration of Message Destinations**: For each message of a specific type, all destination extensions should be categorized under a single entry. The following example is incorrect:

  ```json
  {
    "connections": [
      {
        "extension": "ext_1",
        "cmd": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              }
            ]
          },
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_3"
              }
            ]
          }
        ]
      }
    ]
  }
  ```

  The correct approach is to integrate all destinations for the same message:

  ```json
  {
    "connections": [
      {
        "extension": "ext_1",
        "cmd": [
          {
            "name": "hello",
            "dest": [
              {
                "extension": "ext_2"
              },
              {
                "extension": "ext_3"
              }
            ]
          }
        ]
      }
    ]
  }
  ```

  Note that messages with the same name can coexist in different types (such as `cmd` and `data`) without causing conflicts.

## Subgraph

The core mechanism of the TEN framework is based on a graph structure consisting of nodes and connections. Subgraphs are a powerful reuse mechanism that allows complex graph structures to be broken down into reusable modules, improving code organization and maintainability.

### Subgraph Design Philosophy

The essence of a graph is to define how data flows between extensions. Subgraphs don't change this fundamental principle in implementation; they act as syntactic sugar that eventually gets flattened into the larger graph and started using the same mechanism as regular graphs. This design both simplifies the development of complex systems and doesn't increase runtime complexity.

#### Design Principles

Subgraph design follows these core principles:

1. **Independence**: Any graph is a complete graph that can run independently or be embedded as a component in other graphs.

2. **Tool-Friendly**: Subgraphs provide additional information to help development tools better understand the graph structure, enhancing the development experience without increasing runtime complexity.

3. **Flattening Mechanism**: Subgraphs are ultimately flattened into standard graph structures to ensure performance and compatibility.

4. **Simplicity**: Subgraph design aims to simplify the development process rather than add complexity, avoiding increases in the complexity of the JSON structure.

The purpose of subgraph design is to allow developers to use a graph as a black box without needing to focus on its internal complexity. Therefore, at the point of reference to a subgraph, no special patching mechanism is provided to adjust the internal state of the subgraph, to reduce complexity. If the subgraph definition needs to be modified, the original definition should be modified directly, rather than patching at the reference point. This is done to avoid complexity spread and increased maintenance costs. For example, when introducing subgraph A into a larger graph B, if the schema definition of an extension property within subgraph A needs to be adjusted, the schema definition of that extension should be modified directly, rather than providing a modification mechanism at the reference point, as this could lead to adverse chain reactions, such as modifying only the extension's schema definition without patching other places, resulting in errors elsewhere.

In other words, subgraphs mainly provide a mapping mechanism to expose elements within the subgraph to the outside, rather than providing a mechanism to patch elements within the subgraph.

### Subgraph Implementation Mechanism

Next, we'll detail the implementation mechanism of subgraphs, including subgraph definition, reference methods, and the flattening process.

#### Subgraph Definition Example

Here's a `subgraph.json` example that can be used as an independent graph or referenced as a subgraph by other graphs:

```json
{
  "nodes": [
    {
      // Define an extension node named ext_c
      "type": "extension",
      "name": "ext_c",
      "addon": "extension_c"
    },
    {
      // Define an extension node named ext_d
      "type": "extension",
      "name": "ext_d",
      "addon": "extension_d"
    }
  ],
  "connections": [
    {
      // ext_c transmits command B to ext_d
      "extension": "ext_c",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              "extension": "ext_d"
            }
          ]
        }
      ]
    }
  ],
  "exposed_messages": [
    // Represents message interfaces exposed by the graph to the outside, mainly for development tools to provide smart prompts
    {
      // Command B of ext_d is exposed to the outside
      "extension": "ext_d",
      "type": "cmd_in",
      "name": "B"
    }
  ],
  "exposed_properties": [
    // Represents properties exposed by the graph to the outside
    {
      "extension": "ext_c",
      "name": "a",
      "alias": "a1"
    }
  ]
}
```

#### Subgraph Reference Example

Example of `graph.json` referencing subgraphs:

```json
{
  "nodes": [
    {
      // Define an extension node named ext_a
      "type": "extension",
      "name": "ext_a",
      "addon": "extension_a"
    },
    {
      // Define an extension node named ext_b
      "type": "extension",
      "name": "ext_b",
      "addon": "extension_b"
    },
    {
      // Reference a subgraph, named subgraph_1
      "type": "subgraph",
      "name": "subgraph_1",
      "source_uri": "./ten_packages/extension/aaa/subgraph.json",
      "property": {
        // The property field written here must exist in the exposed_properties field of the subgraph,
        // otherwise it will be an error condition
        "app_id": "${env:AGORA_APP_ID}",
        "token": "<agora_token>",
        "channel": "ten_agent_test"
      }
    },
    {
      // Reference a subgraph, named subgraph_2
      "type": "subgraph",
      "name": "subgraph_2",
      "source_uri": "./ten_packages/extension/bbb/subgraph.json"
    }
  ],
  "connections": [
    {
      "extension": "ext_a",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              // The first destination is ext_b
              "extension": "ext_b"
            },
            {
              // The second destination is ext_d in the subgraph, which is an advanced usage
              "extension": "subgraph_1:ext_d"
            },
            {
              // The third destination is the subgraph, but this requires the subgraph to explicitly expose the cmd_in interface B,
              // otherwise it will be considered an error condition
              "subgraph": "subgraph_2"
            }
          ]
        }
      ]
    },
    {
      // ext_c in the subgraph transmits cmd H to ext_a, which is an advanced usage
      "extension": "subgraph_1:ext_c",
      "cmd": [
        {
          "name": "H",
          "dest": [
            {
              "extension": "ext_a"
            }
          ]
        }
      ]
    },
    {
      // subgraph_2 transmits cmd H to ext_a, but this requires the subgraph to expose the cmd_out interface H,
      // otherwise it will be considered an error condition
      "subgraph": "subgraph_2",
      "cmd": [
        {
          "name": "H",
          "dest": [
            {
              "extension": "ext_a"
            }
          ]
        }
      ]
    }
  ]
}
```

#### Key Concepts

The subgraph mechanism introduces three key concepts:

1. **Message Exposure** (exposed_messages):
   - Subgraphs declare interfaces exposed to the outside through the `exposed_messages` field
   - Mainly for development tools to implement smart prompts and checks
   - Hides subgraph internal details, enhancing the development experience

2. **Property Exposure** (exposed_properties):
   - Subgraphs declare properties exposed to the outside through the `exposed_properties` field
   - Mainly for development tools to implement smart prompts and checks
   - Hides subgraph internal details, enhancing the development experience

3. **Subgraph Reference and Naming**:
   - Reference other graph files through `"type": "subgraph"`
   - Each subgraph has a unique identifying name, serving as a namespace
   - Prevents conflicts between elements with the same name in different subgraphs

4. **Cross-Graph Connections**:
   - Reference elements inside subgraphs through namespace syntax (like `subgraph_1:ext_d`), or reference subgraphs through the `subgraph` field
   - Makes elements inside subgraphs interactable with the main graph
   - Builds complex cross-graph message flows

In summary, the `exposed_messages` and `exposed_properties` fields describe how messages flow inward from the graph boundary, and development tools use these fields to provide smart prompts, making it easier for developers to specify how messages flow toward the graph boundary.

#### Flattening Mechanism

Eventually, graphs referencing subgraphs will be flattened into regular graph structures, ensuring runtime uniformity and efficiency. However, this flattening result won't be seen by users; it's flattened into memory for use in the TEN runtime or TEN manager. Note that in the flattened graph definition, it's just the original extensions and the connections between these extensions.

```json
{
  "nodes": [
    {
      "type": "extension",
      "name": "ext_a",
      "addon": "extension_a"
    },
    {
      "type": "extension",
      "name": "ext_b",
      "addon": "extension_b"
    },
    {
      // ext_c in the subgraph is flattened, with the subgraph name as a prefix
      "type": "extension",
      "name": "subgraph_1_ext_c",
      "addon": "extension_c"
    },
    {
      // ext_d in the subgraph is flattened, with the subgraph name as a prefix
      "type": "extension",
      "name": "subgraph_1_ext_d",
      "addon": "extension_d",
      "property": {
        // The property field defined when referencing the subgraph is flattened to the property field of the corresponding extension
        "app_id": "${env:AGORA_APP_ID}"
      }
    },
    {
      // ext_e in the subgraph is flattened, with the subgraph name as a prefix
      "type": "extension",
      "name": "subgraph_2_ext_e",
      "addon": "extension_e"
    }
  ],
  "connections": [
    {
      "extension": "ext_a",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              "extension": "ext_b"
            },
            {
              "extension": "subgraph_1_ext_d"
            },
            {
              "extension": "subgraph_2_ext_e"
            }
          ]
        }
      ]
    },
    {
      "extension": "subgraph_1_ext_c",
      "cmd": [
        {
          "name": "H",
          "dest": [
            {
              "extension": "ext_a"
            }
          ]
        }
      ]
    },
    {
      // Internal connections of the subgraph are also flattened and included
      "extension": "subgraph_1_ext_c",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              "extension": "subgraph_1_ext_d"
            }
          ]
        }
      ]
    }
  ]
  // The exposed_messages and exposed_properties fields are discarded during the flattening process
}
```

The subgraph flattening mechanism follows these rules:

1. Before flattening, the colon (`:`) symbol indicates elements are located within a subgraph (such as `subgraph_1:ext_d`).

2. After flattening, element names within subgraphs add the subgraph name as a prefix (such as `subgraph_1_ext_c`) to ensure global uniqueness.

3. The flattened graph definition no longer contains the colon symbol, distinguishing between pre- and post-flattening states.

4. Internal connections within subgraphs are preserved and included in the flattened graph, ensuring functional completeness.

### Advanced Features and Applications

As project complexity increases, the advanced features of subgraphs can help better organize and manage the system.

#### Message Conversion and Subgraphs

Subgraphs fully support the message conversion (msg_conversion) mechanism for handling message format conversions between different interfaces:

```json
{
  "nodes": [
    {
      "type": "extension",
      "name": "ext_a",
      "addon": "addon_a"
    },
    {
      "type": "extension",
      "name": "ext_b",
      "addon": "addon_b"
    },
    {
      "type": "subgraph",
      "name": "subgraph_1",
      "source_uri": "http://a.b.c.d/subgraph.json"
    }
  ],
  "connections": [
    {
      "extension": "ext_a",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              "extension": "ext_b",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            },
            {
              "extension": "subgraph_1:ext_d",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            },
            {
              "subgraph": "subgraph_2",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            }
          ]
        }
      ]
    }
  ]
}
```

Development tools can use the `exposed_messages` information to suggest compatibility and provide a message conversion configuration interface. Once configured, the conversion rules are automatically written into the graph definition, simplifying the development process.

After flattening, the message conversion rules are correctly preserved, ensuring that runtime behavior matches design intent:

```json
{
  "nodes": [
    {
      "type": "extension",
      "name": "ext_a",
      "addon": "addon_a"
    },
    {
      "type": "extension",
      "name": "ext_b",
      "addon": "addon_b"
    },
    {
      "type": "extension",
      "name": "subgraph_1_ext_c",
      "addon": "addon_c"
    },
    {
      "type": "extension",
      "name": "subgraph_1_ext_d",
      "addon": "addon_d"
    },
    {
      "type": "extension",
      "name": "subgraph_2_ext_e",
      "addon": "addon_e"
    }
  ],
  "connections": [
    {
      "extension": "ext_a",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              "extension": "ext_b",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            },
            {
              "extension": "subgraph_1_ext_d",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            },
            {
              "extension": "subgraph_2_ext_e",
              "msg_conversion": {
                "type": "per_property",
                "rules": [
                  {
                    "path": "extra_data",
                    "conversion_mode": "fixed_value",
                    "value": "tool_call"
                  }
                ],
                "keep_original": true
              }
            }
          ]
        }
      ]
    }
  ]
}
```

Through this approach, developers can flexibly handle message format differences between different components without needing to worry about underlying implementation details.

## The Meaning of "subgraph_1:ext_c"

In previous examples, `subgraph_1` in `subgraph_1:ext_c` doesn't represent the subgraph itself, but references an element in the `nodes` field. In subgraph applications, `subgraph_1` can be viewed as a namespace.

Through this mechanism, extensions in different locations can be specified as sources or destinations in graph connections, enabling connections across multiple graphs.

The core concept is: graph connections are essentially connections between extensions. Through this mechanism, different types of elements in the `nodes` field can be specified as sources or destinations for connections, enabling connections across multiple subgraphs or even multiple graphs.

## Connections Across Multiple Graphs

Besides subgraphs, similar mechanisms can be used to specify connections with other graphs in a graph.

### Connecting to Predefined Graphs in the Same TEN App

Example: How to connect to a predefined graph in the same TEN app from another graph:

```json
{
  "nodes": [
    {
      // Define an extension named ext_a
      "type": "extension",
      "name": "ext_a",
      "addon": "extension_a"
    },
    {
      // Define an extension named ext_b
      "type": "extension",
      "name": "ext_b",
      "addon": "extension_b"
    },
    {
      // Reference another graph, graph ID is default
      "type": "graph",
      "graph_id": "default"
    }
  ],
  "connections": [
    {
      "extension": "ext_a",
      "cmd": [
        {
          "name": "B",
          "dest": [
            {
              // First destination is ext_b
              "extension": "ext_b"
            },
            {
              // Second destination is ext_d in another graph
              "extension": "default:ext_d"
            }
          ]
        }
      ]
    },
    {
      // ext_c in another graph transmits cmd H to ext_a
      "extension": "default:ext_c",
      "cmd": [
        {
          "name": "H",
          "dest": [
            {
              "extension": "ext_a"
            }
          ]
        }
      ]
    },
    {
      // Another graph transmits cmd X to ext_a, but this requires the other graph to expose the cmd_out interface X,
      // otherwise it will be considered an error condition. This error condition can be reported during static checking if it can be detected,
      // or at runtime.
      "graph": "default",
      "cmd": [
        {
          "name": "X",
          "dest": [
            {
              "extension": "ext_a"
            }
          ]
        }
      ]
    }
  ]
}
```

### Types of Graph Nodes

1. Subgraph

   ```json
   {
     "type": "subgraph",
     "name": "subgraph_1", // meaning of namespace
     "source_uri": "http://a.b.c.d/subgraph.json"
   }
   ```

2. Local graph

   ```json
   {
     "type": "graph",
     "graph_name": "default",
     "singlton": true
   }
   ```

   ```json
   {
     "type": "graph",
     "graph_name": "default",
     "singlton": false
   }
   ```

3. Remote graph

   ```json
   {
     "type": "graph",
     "graph_name": "default",
     "singlton": true,
     "app": "msgpack:://127.0.0.1:8002/"
   }
   ```

   ```json
   {
     "type": "graph",
     "graph_name": "default",
     "singlton": false,
     "app": "msgpack:://127.0.0.1:8002/"
   }
   ```
